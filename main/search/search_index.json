{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"user-guide/","title":"Getting Started","text":"<p>jshiki provides a safe and easy way to evaluate expressions. jshiki only has one lightweight dependency, acorn, which it uses parse expressions.</p> <p>Getting started with jshiki is easy. First, install jshiki using your package manager of choice:</p> Yarn <pre><code>yarn add jshiki\n</code></pre> npm <pre><code>npm install jshiki\n</code></pre> pnpm <pre><code>pnpm add jshiki\n</code></pre> <p>Then, get going! jshiki's API is simple:</p> <ul> <li> <p>The <code>parse()</code> function takes an expression and returns a function that evaluates that expression.</p> <pre><code>const jshiki = require('jshiki')\n\nconst expression = jshiki.parse('(5 + 7) / 3')\nconst result = expression()\n// result =&gt; 4\n</code></pre> </li> <li> <p>The <code>evaluate()</code> function takes an expression and returns the result of evaluating that expression.</p> <pre><code>const jshiki = require('jshiki')\n\nconst result = jshiki.evaluate('(5 + 7) / 3')\n// result =&gt; 4\n</code></pre> </li> </ul> <p>You can use asynchronous expressions, too!</p> <ul> <li> <p>The <code>parseAsync()</code> function creates an asynchronous expression.</p> <pre><code>const jshiki = require('jshiki')\n\nconst expression = jshiki.parseAsync('(await b() + 7) / 3')\nconst result = await expression({ b: async () =&gt; 5 })\n// result =&gt; 4\n</code></pre> </li> <li> <p>The <code>evaluateAsync()</code> function evaluates an asynchronous expression.</p> <pre><code>const jshiki = require('jshiki')\n\nconst result = await jshiki.evaluateAsync('(await b() + 7) / 3', {\n  scope: { b: async () =&gt; 5 }\n})\n// result =&gt; 4\n</code></pre> </li> </ul> <p>Take a look at the type definitions to see the function signatures.</p> <p>You can use all of the below in expressions:</p> <ul> <li>Booleans</li> <li><code>undefined</code>, <code>null</code></li> <li>Numeric literals (including BigInts, <code>NaN</code>, and <code>Infinity</code>)</li> <li>String literals (including template strings)</li> <li>Regex literals (<code>/foo/g</code>)</li> <li>Array literals (including sparse arrays)</li> <li>Object literals (<code>{ prop: 'value' }</code>)</li> <li>Function calls (<code>func()</code>)</li> <li>Member access (<code>obj.prop</code>)</li> <li>Optional chaining (<code>obj?.prop?.()</code>)</li> <li>Nullish coalescing (<code>obj ?? 'default'</code>)</li> </ul> <p>Next, we'll look at how to let expressions access data not contained in the expression itself.</p>"},{"location":"user-guide/accessing-data/","title":"Accessing Data","text":"<p>You can pass expressions an object, the properties of which jshiki will treat as globals in the expression's context. In jshiki, this object is referred to as the scope.</p> <pre><code>const expression = jshiki.parse(\"`Hello! My name's ${name.trim()}`\")\nconst result = expression({ name: ' Azumi ' })\n// result =&gt; \"Hello! My name's Azumi\"\n</code></pre> <p>If using <code>evaluate()</code>, you can pass the scope object as the value of the <code>scope</code> property on the options object:</p> <pre><code>const result = jshiki.evaluate(\"`Hello! My name's ${name.trim()}`\", {\n  scope: { name: ' Azumi ' },\n})\n// result =&gt; \"Hello! My name's Azumi\"\n</code></pre> <p>Expressions cannot access any variables other than those in the scope object. They also cannot use assignment statements.</p> <pre><code>global.baz = 'qux'\nlet foo = 'bar'\n\njshiki.evaluate('foo')\n// returns undefined\n\njshiki.parse('baz = \"quux\"')\n// throws Error: Unsupported node type: AssignmentExpression\n</code></pre>"},{"location":"user-guide/accessing-data/#preventing-data-manipulation","title":"Preventing Data Manipulation","text":"<p>While jshiki prevents expressions from using assignment statements, it does not prevent them from changing data using functions. For example, arrays have a <code>splice()</code> method that removes an element from the array. An expression could call this method and mutate the array:</p> <pre><code>const array = [1, 2, 3]\n\njshiki.evaluate('array.splice(1, 1)', { scope: { array } })\n// returns [2]\n// array =&gt; [1, 3]\n</code></pre> <p>There are several good practices to safeguard your data from manipulation by expressions:</p> <ul> <li>Only pass objects to jshiki that don't have methods that can change data.</li> <li>Block the use of function calls (the next section will go into more detail).     <pre><code>const array = [1, 2, 3]\n\njshiki.evaluate('array.splice(1, 1)', {\n  expressions: {\n    calls: false,\n  }\n  scope: { array },\n})\n// throws Error: Function calls are not allowed.\n</code></pre></li> <li> <p>If you are passing an object that contains such a method:</p> <ul> <li> <p>Make a copy of the object so that the original is unchanged if the expression calls the method in question.</p> <pre><code>const array = [1, 2, 3]\n\njshiki.evaluate('array.splice(1, 1)', {\n  scope: { array: array.slice() },\n})\n// returns [2]\n// array =&gt; [1, 2, 3]\n</code></pre> </li> <li> <p>Use rules to prevent expressions from accessing methods you don't want them to access.</p> <pre><code>const array = [1, 2, 3]\n\njshiki.evaluate('array.splice(1, 1)', {\n  scope: { array },\n  // requires a matching allow rule before allowing access\n  explicitAllow: true,\n  // allows access to `array`, but not to any properties of `array`\n  rules: [{ allow: 'array' }],\n})\n// throws TypeError: evaluatedObject[property(...)] is not a function\n\n// or\n\njshiki.evaluate('array.splice(1, 1)', {\n  scope: { array },\n  // blocks access to any property named `splice` on any object\n  rules: [{ block: '**.splice' }],\n})\n// throws TypeError: evaluatedObject[property(...)] is not a function\n</code></pre> </li> </ul> </li> </ul> <p>Next, we'll cover how to limit what kind of syntax is allowed in expressions.</p>"},{"location":"user-guide/limiting-syntax/","title":"Limiting Syntax","text":"<p>jshiki lets you limit what syntax is allowed in expressions by letting you:</p> <ul> <li>Disallow certain operators</li> <li>Disallow certain literals and expressions</li> </ul>"},{"location":"user-guide/limiting-syntax/#disallowing-operators","title":"Disallowing operators","text":"<p>jshiki lets you block specific unary, binary, and logical operators, as well as the ternary/conditional operator.</p> <p>For each type of operator aside from the ternary operator, you can either use an allow list, which will only allow the operators you specify, or a block list, which will block all operators you specify.</p> <p>Here's an example in which we block the use of the binary <code>+</code> operator (not to be confused with the unary <code>+</code> operator, e.g. <code>+1</code>):</p> <pre><code>// throws Error: Binary operator + is not allowed\njshiki.parse('1 + 2', {\n  operators: {\n    // blocks the binary + operator\n    binary: { block: ['+'] },\n  }\n})\n</code></pre> <p>If instead we were to opt for an allow list, we could specify only the operators we want to allow. Here's an example in which we allow only the logical operators <code>&amp;&amp;</code> and <code>||</code>:</p> <pre><code>const options = {\n  operators: {\n    // allows only the logical operators &amp;&amp; and ||\n    logical: { allow: ['&amp;&amp;', '||'] },\n  }\n}\n\njshiki.evaluate('1 &amp;&amp; 2 || 3', options) // returns 2\n\n// throws Error: Logical operator ?? is not allowed\njshiki.evaluate('null ?? 1', options)\n</code></pre> <p>The conditional operator takes a boolean instead since it is the only ternary operator in Javascript \u2014 <code>true</code> allows it, <code>false</code> blocks it.</p> <pre><code>// throws Error: Conditional/ternary operator is not allowed\njshiki.parse('1 ? 2 : 3', {\n  operators: {\n    // blocks the ternary/conditional operator\n    ternary: false,\n  }\n})\n</code></pre> <p>In full, the operators options object is as follows:</p> <ul> <li><code>operators.unary</code> \u2014 Unary operators (e.g. <code>!true</code>, <code>-1</code>)</li> <li><code>operators.binary</code> \u2014 Binary operators (e.g. <code>1 + 2</code>, <code>1 !== 2</code>)</li> <li><code>operators.logical</code> \u2014 Logical operators (e.g. <code>true &amp;&amp; false</code>, <code>null ?? 1</code>)</li> <li><code>operators.ternary</code> \u2014 Ternary/conditional operator (e.g. <code>a === b ? 2 : 3</code>)</li> </ul> <p>All supported operators, except for <code>typeof</code>, <code>in</code>, and <code>instanceof</code>, are allowed by default. For an exhaustive list, see the API docs.</p>"},{"location":"user-guide/limiting-syntax/#disallowing-syntax","title":"Disallowing syntax","text":"<p>You can also block specific syntax by setting the corresponding <code>syntax</code> option to <code>false</code>. For example, you might want to disallow the use of function calls:</p> <pre><code>// throws Error: Function calls are not allowed\njshiki.parse('foo()', {\n  syntax: {\n    // blocks the use of function calls\n    calls: false,\n  }\n})\n</code></pre> <p>In full, the syntax options object is as follows:</p> <ul> <li><code>syntax.memberAccess</code> \u2014 Member access (e.g. <code>foo.bar</code>, <code>foo['bar']</code>)</li> <li><code>syntax.calls</code> \u2014 Function calls (e.g. <code>foo()</code>)</li> <li><code>syntax.taggedTemplates</code> \u2014 Tagged template literals (e.g. <code>tag`foo ${bar}`</code>)</li> <li><code>syntax.templates</code> \u2014 Template literals (e.g. <code>`foo ${bar}`</code>)</li> <li><code>syntax.objects</code> \u2014 Object literals (e.g. <code>{ foo: 1 }</code>)</li> <li><code>syntax.arrays</code> \u2014 Array literals (e.g. <code>[1, 2, 3]</code>)</li> <li><code>syntax.regexes</code> \u2014 Regular expressions (e.g. <code>/foo/g</code>)</li> </ul> <p>Next, we'll examine another way jshiki lets you limit what expressions can do \u2014 rules.</p>"},{"location":"user-guide/rules/","title":"Rules","text":"<p>IMPORTANT! Do not rely on rules for data security! You should never expose sensitive data to expressions that you do not have complete control over. See the security section of the user guide for good habits to follow to keep your data safe.</p> <p>jshiki supports defining rules that determine whether or not a property on the scope object is accessible to an expression. Rules are defined as an array of objects, where each object has a <code>allow</code> or <code>block</code> property that represents a path to a property. Any property to which access is blocked will return <code>undefined</code> when evaluated.</p> <p>Take a look at the type definitions for a more technical explanation.</p> <p>For example, the following rules will allow access to <code>user.name</code> and <code>user.postalCode</code>, but will block access to <code>user.groups</code>:</p> <pre><code>const options = {\n  rules: [\n    { allow: 'user.name' },\n    { allow: ['user', 'postalCode'] },\n    { block: 'user.groups' },\n  ],\n}\n</code></pre> <p>IMPORTANT! Rules will not apply to any properties of values that aren't objects or functions. This behaviour is a result of jshiki's rules implementation using proxies under the hood \u2014 proxies can only be created for objects or functions.</p> <pre><code>const options = {\n  rules: [{ block: 'length' }],\n  scope: 'str',\n}\nconst result = jshiki.evaluate('length', options)\n// result =&gt; 3\n</code></pre>"},{"location":"user-guide/rules/#requiring-explicit-allowing-of-access","title":"Requiring Explicit Allowing of Access","text":"<p>By default, jshiki will allow access to all properties of the scope object unless a block rule applies. However, you can instead require that an allow rule matches the property before allowing the expression to access it by setting the <code>explicitAllow</code> option to <code>true</code>.</p> <pre><code>const options = {\n  explicitAllow: true,\n  rules: [{ allow: 'user.name' }],\n}\n// allows access to user and user.name\n// does not allow access to user.groups or any other property\n</code></pre> <p>Requiring allow rules is safer since it prevents access to any property you may not have accounted for, such as in the case that:</p> <ul> <li>You're unaware of all the properties on an object</li> <li>A new property is added to the object after you've written your code</li> <li>The properties on the object vary at runtime</li> </ul> <p>However, in certain circumstances, this approach may be more restrictive than necessary. Use your best judgment and think about the tradeoffs. Some things to consider:</p> <ul> <li>Are you using a library that exposes properties on an object that you don't know about?</li> <li>Are any of the entities in the scope mutable?</li> <li>Do any of the objects in the scope have properties that vary at runtime?</li> </ul>"},{"location":"user-guide/rules/#wildcards","title":"Wildcards","text":"<p>The <code>*</code> wildcard matches any property. For example, the following rule allows access to any property <code>length</code> on any member of <code>user</code>. Implicitly, the rule also allows access to any member of <code>user</code> since you must be able to access <code>user</code> to access its <code>length</code> property.</p> <pre><code>const rules = [{ allow: 'user.*.length' }]\n// allows user.name.length, user.groups.length, etc.\n// also allows user.name, user.createdAt, etc.\n</code></pre> <p>You can also use <code>**</code> to match any property at any depth. For example, the following rule will block access to any member named <code>splice</code> regardless of what object or property it is on:</p> <pre><code>const rules = [{ block: '**.splice' }]\n// blocks user.groups.splice, searchResults.splice, etc.\n</code></pre> <p>If you need to refer to a property named <code>*</code> or <code>**</code>, you can use <code>'\\\\*'</code> or <code>'\\\\**'</code>.</p> <pre><code>const rules = [{ block: 'user.\\\\*' }]\n// blocks user['*']\nconst rules = [{ block: ['user', '\\\\**'] }]\n// blocks user['**']\n</code></pre>"},{"location":"user-guide/rules/#precedence","title":"Precedence","text":"<p>jshiki evaluates rules in the order in which they are defined \u2014 each rule overrides any previously defined rules.</p> <p>In the following example, the rule blocking access to <code>user.groups</code> will override the rule allowing access to any property of <code>user</code>. The result is that all properties of <code>user</code> will be allowed access, except for <code>user.groups</code>.</p> <pre><code>const rules = [{ allow: 'user.*' }, { block: 'user.groups' }]\n// allows access to user.name, user.createdAt, etc., but not user.groups\n</code></pre> <p>If we were to define the rules in the opposite order, the <code>user.*</code> rule would override the <code>user.groups</code> rule. This would result in the expression being allowed access to all properties of <code>user</code>, including <code>user.groups</code>.</p> <pre><code>const rules = [{ block: 'user.groups' }, { allow: 'user.*' }]\n// allows access to user.name, user.createdAt, etc., including user.groups\n</code></pre> <p>In the following section, we'll discuss how to practice good data security when using jshiki.</p>"},{"location":"user-guide/security/","title":"Security","text":"<p>IMPORTANT! jshiki is not a true sandbox. If you need to be able to evaluate arbitrary code of unknown origin, you may want to consider using vm2 or a similar library.</p> <p>NOTE: Many factors can affect the security of your application. Though jshiki prevents most avenues through which expressions can gain unwanted access to or modify data, using jshiki alone does not guarantee that every expression you evaluate will be safe.</p> <p>This section is not an exhaustive list of all security concerns but rather a high-level overview of some of the most common problems to consider when using jshiki. The OWASP NodeJS security cheat sheet is a good place to start for a more in-depth look at security in Javascript applications.</p> <p>jshiki is designed to be a safe and secure environment for evaluating expressions. It achieves this through methods we've discussed elsewhere in this guide, such as preventing access to any data that isn't explicitly exposed and limiting the operations that expressions can perform. However, this is not enough to contain all possible attacks.</p> <p>When you pass a scope object to an expression, you effectively open up the sandbox in which jshiki evaluates it since the scope object is outside of the expression's context. Through this opening, it may, in theory, be possible for the expression to gain access to data that is not explicitly exposed, for several reasons, including, but not limited to:</p> <ul> <li> <p>An oversight or a change in a third-party library, dependency, or data layer results in additional data being added to an object exposed to the expression without the consuming program's developer's knowledge.</p> <p>Example: A change elsewhere in an application adds a new property to a set of data fetched from an API, which is then directly exposed to expressions. The developer of the consuming program does not know that someone else added the new property.</p> <p>If an expression attempts to access that data, it may gain access to the new property.</p> </li> <li> <p>A function or property getter/setter on an object exposed to the expression unexpectedly mutates data.</p> <p>Example: A getter method on an object changes some internal value which determines if a block of code gets executed. The code that calls jshiki provides the expression with the object with the getter method.</p> <p>An attacker could use this behaviour to write expressions that would result in the execution of code that is not intended to be executed.</p> </li> <li> <p>A vulnerability in the Javascript engine allows arbitrary code execution and can be exploited with methods or properties of a particular type of object, such as an array.</p> <p>Example: A new, undisclosed vulnerability in the V8 Javascript engine that allows arbitrary code execution can be exploited by providing specific parameters to the <code>Array.prototype.splice</code> method.</p> <p>Now, suppose an array is now made available to an expression. In that case, an attacker could write an expression that would execute arbitrary code, and jshiki would evaluate it unless a rule blocked the <code>splice</code> method.</p> </li> </ul>"},{"location":"user-guide/security/#staying-safe","title":"Staying Safe","text":"<p>So, how do we use jshiki while avoiding common pitfalls? We can take a few steps to keep expression execution safe:</p> <ul> <li> <p>Limit the data you pass to expressions to the minimal set of data required to perform the desired operation.</p> <p>Instead of passing an entire object full of data to an expression, provide only the necessary portion of the data as a separate object.</p> <p>For example, if you want an expression to access a user's <code>name</code> and <code>age</code> properties, you can pass those properties to the expression alone instead of passing the entire object.</p> </li> <li> <p>Sanitize the data you pass to expressions.</p> <p>Even when selecting a subset of data to pass to an expression, it is possible for the values or types of the fields themselves to change to something unexpected. Make sure that the data you provide to an expression is what you expect it to be.</p> <p>For example, if you pass a user's <code>created</code> field to an expression, but the field's value is later changed from a string to an object, it may expose different data to the expression than it did before.</p> </li> <li> <p>Restrict creating expressions to only those that need to be able to do so.</p> <p>If there is no need for certain users to write expressions, there is no reason why they should have access to create them. The fewer people have access to creating expressions, the less likely you are to encounter an attack.</p> <p>If, for example, you have a site that uses expressions for business rules, and you want to allow users to create expressions, you should assign the ability to edit expressions only to those users who need to edit business rules.</p> </li> </ul> <p>Even with these precautions in place, never assume that your code is safe. Any code that you run that you do not write or have direct control over carries with it the risk of an attack \u2014 even with an expression evaluator like jshiki.</p>"}]}