{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"user-guide/","text":"jshiki provides a safe and easy way to evaluate expressions. jshiki only has one lightweight dependency, acorn , which it uses parse expressions. Getting started with jshiki is easy. First, install jshiki using your package manager of choice: Yarn yarn add jshiki npm npm install jshiki pnpm pnpm add jshiki Then, get going! jshiki's API is simple: The parse () function takes an expression and returns a function that evaluates that expression. const jshiki = require ( 'jshiki' ) const expression = jshiki . parse ( '(5 + 7) / 3' ) const result = expression () // result => 4 The evaluate () function takes an expression and returns the result of evaluating that expression. const jshiki = require ( 'jshiki' ) const result = jshiki . evaluate ( '(5 + 7) / 3' ) // result => 4 Take a look at the type definitions to see the function signatures. You can use all of the below in expressions: Booleans undefined , null Numeric literals (including BigInts, NaN , and Infinity ) String literals (including template strings) Regex literals ( /foo/g ) Array literals (including sparse arrays) Object literals ( { prop : 'value' } ) Function calls ( func () ) Member access ( obj . prop ) Optional chaining ( obj ? . prop ? .() ) Nullish coalescing ( obj ?? 'default' ) Next, we'll look at how to let expressions access data not contained in the expression itself.","title":"Getting Started"},{"location":"user-guide/accessing-data/","text":"You can pass expressions an object, the properties of which jshiki will treat as globals in the expression's context. In jshiki, this object is referred to as the scope . const expression = jshiki . parse ( \"`Hello! My name's ${name.trim()}`\" ) const result = expression ({ name : ' Azumi ' }) // result => \"Hello! My name's Azumi\" If using evaluate () , you can pass the scope object as the value of the scope property on the options object: const result = jshiki . evaluate ( \"`Hello! My name's ${name.trim()}`\" , { scope : { name : ' Azumi ' }, }) // result => \"Hello! My name's Azumi\" Expressions cannot access any variables other than those in the scope object. They also cannot use assignment statements. global . baz = 'qux' let foo = 'bar' jshiki . evaluate ( 'foo' ) // returns undefined jshiki . parse ( 'baz = \"quux\"' ) // throws Error: Unsupported node type: AssignmentExpression Preventing Data Manipulation While jshiki prevents expressions from using assignment statements, it does not prevent them from changing data using functions. For example, arrays have a splice () method that removes an element from the array. An expression could call this method and mutate the array: const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array } }) // returns [2] // array => [1, 3] There are several good practices to safeguard your data from manipulation by expressions: Only pass objects to jshiki that don't have methods that can change data. Block the use of function calls (the next section will go into more detail). const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { expressions : { calls : false , } scope : { array }, }) // throws Error: Function calls are not allowed. If you are passing an object that contains such a method: Make a copy of the object so that the original is unchanged if the expression calls the method in question. const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array : array . slice () }, }) // returns [2] // array => [1, 2, 3] Use rules to prevent expressions from accessing methods you don't want them to access. const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array }, // requires a matching allow rule before allowing access explicitAllow : true , // allows access to `array`, but not to any properties of `array` rules : [{ allow : 'array' }], }) // throws TypeError: evaluatedObject[property(...)] is not a function // or jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array }, // blocks access to any property named `splice` on any object rules : [{ block : '**.splice' }], }) // throws TypeError: evaluatedObject[property(...)] is not a function Next, we'll cover how to limit what kind of syntax is allowed in expressions.","title":"Accessing Data"},{"location":"user-guide/accessing-data/#preventing-data-manipulation","text":"While jshiki prevents expressions from using assignment statements, it does not prevent them from changing data using functions. For example, arrays have a splice () method that removes an element from the array. An expression could call this method and mutate the array: const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array } }) // returns [2] // array => [1, 3] There are several good practices to safeguard your data from manipulation by expressions: Only pass objects to jshiki that don't have methods that can change data. Block the use of function calls (the next section will go into more detail). const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { expressions : { calls : false , } scope : { array }, }) // throws Error: Function calls are not allowed. If you are passing an object that contains such a method: Make a copy of the object so that the original is unchanged if the expression calls the method in question. const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array : array . slice () }, }) // returns [2] // array => [1, 2, 3] Use rules to prevent expressions from accessing methods you don't want them to access. const array = [ 1 , 2 , 3 ] jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array }, // requires a matching allow rule before allowing access explicitAllow : true , // allows access to `array`, but not to any properties of `array` rules : [{ allow : 'array' }], }) // throws TypeError: evaluatedObject[property(...)] is not a function // or jshiki . evaluate ( 'array.splice(1, 1)' , { scope : { array }, // blocks access to any property named `splice` on any object rules : [{ block : '**.splice' }], }) // throws TypeError: evaluatedObject[property(...)] is not a function Next, we'll cover how to limit what kind of syntax is allowed in expressions.","title":"Preventing Data Manipulation"},{"location":"user-guide/limiting-syntax/","text":"jshiki lets you limit what syntax is allowed in expressions by letting you: Disallow certain operators Disallow certain literals and expressions Disallowing operators jshiki lets you block specific unary operators, binary operators, logical operators, and the ternary/conditional operator. For each type of operator aside from the ternay operator, you can either use an allow list, which will only allow the operators you specify, or a block list, which will block all operators you specify. Here's an example in which we block the use of the binary + operator (not to be confused with the unary + operator, e.g. + 1 ): // throws Error: Binary operator + is not allowed jshiki . parse ( '1 + 2' , { operators : { // blocks the binary + operator binary : { block : [ '+' ] }, } }) If instead we were to opt for an allow list, we could specify only the operators we want to allow. Here's an example in which we allow only the logical operators && and || : const options = { operators : { // allows only the logical operators && and || logical : { allow : [ '&&' , '||' ] }, } } jshiki . evaluate ( '1 && 2 || 3' , options ) // returns 2 // throws Error: Logical operator ?? is not allowed jshiki . evaluate ( 'null ?? 1' , options ) The conditional operator takes a boolean instead since it is the only ternary operator in Javascript \u2014 true allows it, false blocks it. // throws Error: Conditional/ternary operator is not allowed jshiki . parse ( '1 ? 2 : 3' , { operators : { // blocks the ternary/conditional operator ternary : false , } }) In full, the operators options object is as follows: operators . unary \u2014 Unary operators (e.g. ! true , - 1 ) operators . binary \u2014 Binary operators (e.g. 1 + 2 , 1 !== 2 ) operators . logical \u2014 Logical operators (e.g. true && false , null ?? 1 ) operators . ternary \u2014 Ternary/conditional operator (e.g. a === b ? 2 : 3 ) All supported operators are allowed by default. For an exhaustive list, see the API docs . Disallowing syntax You can also block specific syntax by setting the corresponding syntax option to false . For example, you might want to disallow the use of function calls: // throws Error: Function calls are not allowed jshiki . parse ( 'foo()' , { syntax : { // blocks the use of function calls calls : false , } }) In full, the syntax options object is as follows: syntax . memberAccess \u2014 Member access (e.g. foo . bar , foo [ 'bar' ] ) syntax . calls \u2014 Function calls (e.g. foo () ) syntax . taggedTemplates \u2014 Tagged template literals (e.g. tag `foo ${ bar } ` ) syntax . templates \u2014 Template literals (e.g. `foo ${ bar } ` ) syntax . objects \u2014 Object literals (e.g. { foo : 1 } ) syntax . arrays \u2014 Array literals (e.g. [ 1 , 2 , 3 ] ) syntax . regexes \u2014 Regular expressions (e.g. /foo/g ) Next, we'll examine another way jshiki lets you limit what expressions can do \u2014 rules.","title":"Limiting Syntax"},{"location":"user-guide/limiting-syntax/#disallowing-operators","text":"jshiki lets you block specific unary operators, binary operators, logical operators, and the ternary/conditional operator. For each type of operator aside from the ternay operator, you can either use an allow list, which will only allow the operators you specify, or a block list, which will block all operators you specify. Here's an example in which we block the use of the binary + operator (not to be confused with the unary + operator, e.g. + 1 ): // throws Error: Binary operator + is not allowed jshiki . parse ( '1 + 2' , { operators : { // blocks the binary + operator binary : { block : [ '+' ] }, } }) If instead we were to opt for an allow list, we could specify only the operators we want to allow. Here's an example in which we allow only the logical operators && and || : const options = { operators : { // allows only the logical operators && and || logical : { allow : [ '&&' , '||' ] }, } } jshiki . evaluate ( '1 && 2 || 3' , options ) // returns 2 // throws Error: Logical operator ?? is not allowed jshiki . evaluate ( 'null ?? 1' , options ) The conditional operator takes a boolean instead since it is the only ternary operator in Javascript \u2014 true allows it, false blocks it. // throws Error: Conditional/ternary operator is not allowed jshiki . parse ( '1 ? 2 : 3' , { operators : { // blocks the ternary/conditional operator ternary : false , } }) In full, the operators options object is as follows: operators . unary \u2014 Unary operators (e.g. ! true , - 1 ) operators . binary \u2014 Binary operators (e.g. 1 + 2 , 1 !== 2 ) operators . logical \u2014 Logical operators (e.g. true && false , null ?? 1 ) operators . ternary \u2014 Ternary/conditional operator (e.g. a === b ? 2 : 3 ) All supported operators are allowed by default. For an exhaustive list, see the API docs .","title":"Disallowing operators"},{"location":"user-guide/limiting-syntax/#disallowing-syntax","text":"You can also block specific syntax by setting the corresponding syntax option to false . For example, you might want to disallow the use of function calls: // throws Error: Function calls are not allowed jshiki . parse ( 'foo()' , { syntax : { // blocks the use of function calls calls : false , } }) In full, the syntax options object is as follows: syntax . memberAccess \u2014 Member access (e.g. foo . bar , foo [ 'bar' ] ) syntax . calls \u2014 Function calls (e.g. foo () ) syntax . taggedTemplates \u2014 Tagged template literals (e.g. tag `foo ${ bar } ` ) syntax . templates \u2014 Template literals (e.g. `foo ${ bar } ` ) syntax . objects \u2014 Object literals (e.g. { foo : 1 } ) syntax . arrays \u2014 Array literals (e.g. [ 1 , 2 , 3 ] ) syntax . regexes \u2014 Regular expressions (e.g. /foo/g ) Next, we'll examine another way jshiki lets you limit what expressions can do \u2014 rules.","title":"Disallowing syntax"},{"location":"user-guide/rules/","text":"Rules IMPORTANT! Do not rely on rules for data security! You should never expose sensitive data to expressions that you do not have complete control over. See the security section of the user guide for good habits to follow to keep your data safe. jshiki supports defining rules that determine whether or not a property on the scope object is accessible to an expression. Rules are defined as an array of objects, where each object has a allow or block property that represents a path to a property. Any property to which access is blocked will return undefined when evaluated. Take a look at the type definitions for a more technical explanation. For example, the following rules will allow access to user . name and user . postalCode , but will block access to user . groups : const options = { rules : [ { allow : 'user.name' }, { allow : [ 'user' , 'postalCode' ] }, { block : 'user.groups' }, ], } Requiring Explicit Allowing of Access By default, jshiki will allow access to all properties of the scope object unless a block rule applies. However, you can instead require that an allow rule matches the property before allowing the expression to access it by setting the explicitAllow option to true . const options = { explicitAllow : true , rules : [{ allow : 'user.name' }], } // allows access to user and user.name // does not allow access to user.groups or any other property Requiring allow rules is safer since it prevents access to any property you may not have accounted for, such as in the case that: You're unaware of all the properties on an object A new property is added to the object after you've written your code The properties on the object vary at runtime However, in certain circumstances, this approach may be more restrictive than necessary. Use your best judgment and think about the tradeoffs. Some things to consider: Are you using a library that exposes properties on an object that you don't know about? Are any of the entities in the scope mutable? Do any of the objects in the scope have properties that vary at runtime? Wildcards The * wildcard matches any property. For example, the following rule allows access to any property length on any member of user . Implicitly, the rule also allows access to any member of user since you must be able to access user to access its length property. const rules = [{ allow : 'user.*.length' }] // allows user.name.length, user.groups.length, etc. // also allows user.name, user.createdAt, etc. You can also use ** to match any property at any depth. For example, the following rule will block access to any member named splice regardless of what object or property it is on: const rules = [{ block : '**.splice' }] // blocks user.groups.splice, searchResults.splice, etc. If you need to refer to a property named * or ** , you can use '\\\\*' or '\\\\**' . const rules = [{ block : 'user.\\\\*' }] // blocks user['*'] const rules = [{ block : [ 'user' , '\\\\**' ] }] // blocks user['**'] Precedence jshiki evaluates rules in the order in which they are defined \u2014 each rule overrides any previously defined rules. In the following example, the rule blocking access to user . groups will override the rule allowing access to any property of user . The result is that all properties of user will be allowed access, except for user.groups . const rules = [{ allow : 'user.*' }, { block : 'user.groups' }] // allows access to user.name, user.createdAt, etc., but not user.groups If we were to define the rules in the opposite order, the user . * rule would override the user . groups rule. This would result in the expression being allowed access to all properties of user , including user.groups . const rules = [{ block : 'user.groups' }, { allow : 'user.*' }] // allows access to user.name, user.createdAt, etc., including user.groups In the following section, we'll discuss how to practice good data security when using jshiki.","title":"Rules"},{"location":"user-guide/rules/#rules","text":"IMPORTANT! Do not rely on rules for data security! You should never expose sensitive data to expressions that you do not have complete control over. See the security section of the user guide for good habits to follow to keep your data safe. jshiki supports defining rules that determine whether or not a property on the scope object is accessible to an expression. Rules are defined as an array of objects, where each object has a allow or block property that represents a path to a property. Any property to which access is blocked will return undefined when evaluated. Take a look at the type definitions for a more technical explanation. For example, the following rules will allow access to user . name and user . postalCode , but will block access to user . groups : const options = { rules : [ { allow : 'user.name' }, { allow : [ 'user' , 'postalCode' ] }, { block : 'user.groups' }, ], }","title":"Rules"},{"location":"user-guide/rules/#requiring-explicit-allowing-of-access","text":"By default, jshiki will allow access to all properties of the scope object unless a block rule applies. However, you can instead require that an allow rule matches the property before allowing the expression to access it by setting the explicitAllow option to true . const options = { explicitAllow : true , rules : [{ allow : 'user.name' }], } // allows access to user and user.name // does not allow access to user.groups or any other property Requiring allow rules is safer since it prevents access to any property you may not have accounted for, such as in the case that: You're unaware of all the properties on an object A new property is added to the object after you've written your code The properties on the object vary at runtime However, in certain circumstances, this approach may be more restrictive than necessary. Use your best judgment and think about the tradeoffs. Some things to consider: Are you using a library that exposes properties on an object that you don't know about? Are any of the entities in the scope mutable? Do any of the objects in the scope have properties that vary at runtime?","title":"Requiring Explicit Allowing of Access"},{"location":"user-guide/rules/#wildcards","text":"The * wildcard matches any property. For example, the following rule allows access to any property length on any member of user . Implicitly, the rule also allows access to any member of user since you must be able to access user to access its length property. const rules = [{ allow : 'user.*.length' }] // allows user.name.length, user.groups.length, etc. // also allows user.name, user.createdAt, etc. You can also use ** to match any property at any depth. For example, the following rule will block access to any member named splice regardless of what object or property it is on: const rules = [{ block : '**.splice' }] // blocks user.groups.splice, searchResults.splice, etc. If you need to refer to a property named * or ** , you can use '\\\\*' or '\\\\**' . const rules = [{ block : 'user.\\\\*' }] // blocks user['*'] const rules = [{ block : [ 'user' , '\\\\**' ] }] // blocks user['**']","title":"Wildcards"},{"location":"user-guide/rules/#precedence","text":"jshiki evaluates rules in the order in which they are defined \u2014 each rule overrides any previously defined rules. In the following example, the rule blocking access to user . groups will override the rule allowing access to any property of user . The result is that all properties of user will be allowed access, except for user.groups . const rules = [{ allow : 'user.*' }, { block : 'user.groups' }] // allows access to user.name, user.createdAt, etc., but not user.groups If we were to define the rules in the opposite order, the user . * rule would override the user . groups rule. This would result in the expression being allowed access to all properties of user , including user.groups . const rules = [{ block : 'user.groups' }, { allow : 'user.*' }] // allows access to user.name, user.createdAt, etc., including user.groups In the following section, we'll discuss how to practice good data security when using jshiki.","title":"Precedence"},{"location":"user-guide/security/","text":"NOTE: Many factors can affect the security of your application. Though jshiki prevents most avenues through which expressions can gain unwanted access to or modify data, using jshiki alone does not guarantee that every expression you evaluate will be safe. This section is not an exhaustive list of all security concerns but rather a high-level overview of some of the most common problems to consider when using jshiki. The OWASP NodeJS security cheat sheet is a good place to start for a more in-depth look at security in Javascript applications. jshiki is designed to be a safe and secure environment for evaluating expressions. It achieves this through methods we've discussed elsewhere in this guide, such as preventing access to any data that isn't explicitly exposed and limiting the operations that expressions can perform. However, this is not enough to contain all possible attacks. When you pass a scope object to an expression, you effectively open up the sandbox in which jshiki evaluates it since the scope object is outside of the expression's context. Through this opening, it may, in theory, be possible for the expression to gain access to data that is not explicitly exposed, for several reasons, including, but not limited to: An oversight or a change in a third-party library, dependency, or data layer results in additional data being added to an object exposed to the expression without the consuming program's developer's knowledge. Example: A change elsewhere in an application adds a new property to a set of data fetched from an API, which is then directly exposed to expressions. The developer of the consuming program does not know that someone else added the new property. If an expression attempts to access that data, it may gain access to the new property. A function or property getter/setter on an object exposed to the expression unexpectedly mutates data. Example: A getter method on an object changes some internal value which determines if a block of code gets executed. The code that calls jshiki provides the expression with the object with the getter method. An attacker could use this behaviour to write expressions that would result in the execution of code that is not intended to be executed. A vulnerability in the Javascript engine allows arbitrary code execution and can be exploited with methods or properties of a particular type of object, such as an array. Example: A new, undisclosed vulnerability in the V8 Javascript engine that allows arbitrary code execution can be exploited by providing specific parameters to the Array . prototype . splice method. Now, suppose an array is now made available to an expression. In that case, an attacker could write an expression that would execute arbitrary code, and jshiki would evaluate it unless a rule blocked the splice method. Staying Safe So, how do we use jshiki while avoiding common pitfalls? We can take a few steps to keep expression execution safe: Limit the data you pass to expressions to the minimal set of data required to perform the desired operation. Instead of passing an entire object full of data to an expression, provide only the necessary portion of the data as a separate object. For example, if you want an expression to access a user's name and age properties, you can pass those properties to the expression alone instead of passing the entire object. Sanitize the data you pass to expressions. Even when selecting a subset of data to pass to an expression, it is possible for the values or types of the fields themselves to change to something unexpected. Make sure that the data you provide to an expression is what you expect it to be. For example, if you pass a user's created field to an expression, but the field's value is later changed from a string to an object, it may expose different data to the expression than it did before. Restrict creating expressions to only those that need to be able to do so. If there is no need for certain users to write expressions, there is no reason why they should have access to create them. The fewer people have access to creating expressions, the less likely you are to encounter an attack. If, for example, you have a site that uses expressions for business rules, and you want to allow users to create expressions, you should assign the ability to edit expressions only to those users who need to edit business rules. Even with these precautions in place, never assume that your code is safe. Any code that you run that you do not write or have direct control over carries with it the risk of an attack \u2014 even with an expression evaluator like jshiki.","title":"Security"},{"location":"user-guide/security/#staying-safe","text":"So, how do we use jshiki while avoiding common pitfalls? We can take a few steps to keep expression execution safe: Limit the data you pass to expressions to the minimal set of data required to perform the desired operation. Instead of passing an entire object full of data to an expression, provide only the necessary portion of the data as a separate object. For example, if you want an expression to access a user's name and age properties, you can pass those properties to the expression alone instead of passing the entire object. Sanitize the data you pass to expressions. Even when selecting a subset of data to pass to an expression, it is possible for the values or types of the fields themselves to change to something unexpected. Make sure that the data you provide to an expression is what you expect it to be. For example, if you pass a user's created field to an expression, but the field's value is later changed from a string to an object, it may expose different data to the expression than it did before. Restrict creating expressions to only those that need to be able to do so. If there is no need for certain users to write expressions, there is no reason why they should have access to create them. The fewer people have access to creating expressions, the less likely you are to encounter an attack. If, for example, you have a site that uses expressions for business rules, and you want to allow users to create expressions, you should assign the ability to edit expressions only to those users who need to edit business rules. Even with these precautions in place, never assume that your code is safe. Any code that you run that you do not write or have direct control over carries with it the risk of an attack \u2014 even with an expression evaluator like jshiki.","title":"Staying Safe"}]}